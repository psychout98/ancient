import java.awt.*;
import java.awt.event.*;
import java.util.*;

import javax.swing.*;

public class Main extends JFrame
		implements ActionListener, KeyListener, MouseListener, MouseMotionListener, MouseWheelListener {

	JPanel centerPanel, menuPanel;
	int curX, curY, iX, iY;
	double curH = 0, curV = 0, angleH = 0, angleV = 0, direc=0;
	boolean dragging = false,spinL=false,spinR=false,rotateSim=false;
	double Stars[];

	Main() throws InterruptedException {
		super("Solar Nebula Formation Simulator");
		this.setSize(1000, 700);
		this.setVisible(false);
		this.setDefaultCloseOperation(3);
		this.setLocationRelativeTo(null);
		this.setLayout(new BorderLayout());
		this.setResizable(false);
		Random r = new Random();
		Stars = new double[4 * (r.nextInt(300) + 300)];
		for (int i = 0; i < Stars.length / 4; i++) {
			Stars[4 * i] = 2*Math.PI*r.nextInt(1000)/1000;
			Stars[(4 * i) + 1] = 2*Math.PI*r.nextInt(1000)/1000;
			Stars[(4 * i) + 2] = r.nextInt(3) + 1;
			Stars[(4 * i) + 3] = r.nextInt(3) + 1;
		}
		centerPanel = new graphic();
		centerPanel.addMouseListener(this);
		centerPanel.addMouseMotionListener(this);
		this.addKeyListener(this);
		menuPanel = new JPanel();
		setMenuPanel();
		JMenuBar mb = new JMenuBar();
		JMenu file = new JMenu("File");
		mb.add(file);
		this.setJMenuBar(mb);
		this.add(menuPanel, BorderLayout.NORTH);
		this.add(centerPanel, BorderLayout.CENTER);
		this.setVisible(true);
		while (true) {
			/*
			if(spinL)
				direc++;
			if(spinR)
				direc--;
			if(Math.abs(direc) == 2*Math.PI)
				direc = 0;
			direc=0;
			if(angleV > Math.PI/2){
			angleV = 89*Math.PI/180;
			angleH += Math.PI;
			direc += Math.PI;
			}
			if(angleV < -Math.PI/2){
				angleV = -89*Math.PI/180;
				angleH += Math.PI;
				direc += Math.PI;
				}
				*/
			if(rotateSim){
			angleH+=Math.PI/360;
			}
			Thread.sleep(42);
			repaint();
		}
	}

	public void setMenuPanel() {
		menuPanel.setLayout(new GridLayout(1, 1)); //
		menuPanel.setPreferredSize(new Dimension(1000, 65));
	}

	public static void main(String[] args) throws InterruptedException {
		Main window = new Main();
	}

	public class graphic extends JPanel {

		public void paint(Graphics p) {
			setSize(1000, 600);
			p.setColor(Color.black);
			p.fillRect(0, 0, 1000, 600);
			//makeStars(p);
			//makeAxis(p);
			int box[] = {500+getXYZ(0,0,0,0),300+getXYZ(0,0,0,1),
					500+getXYZ(20,0,10,0),300+getXYZ(20,0,10,1),
					500+getXYZ(0,10,10,0),300+getXYZ(0,10,10,1),
					500+getXYZ(20,10,0,0),300+getXYZ(20,10,0,1),
					500+getXYZ(0,0,10,0),300+getXYZ(0,0,10,1),
					500+getXYZ(20,0,0,0),300+getXYZ(20,0,0,1),
					500+getXYZ(0,10,0,0),300+getXYZ(0,10,0,1),
					500+getXYZ(20,10,10,0),300+getXYZ(20,10,10,1)};
			for(int i=0;i<4;i++)
				for(int j=4;j<8;j++)
					if(j!=7-i)
			p.drawLine(box[2*i],box[(2*i)+1],box[(2*j)],box[(2*j)+1]);
		}

		public void makeStars(Graphics p) {
			p.setColor(Color.white);
			for (int i = 0; i < Stars.length / 4; i++){
				int sX = getXYZ(40*Math.cos(Stars[4*i])*Math.cos(Stars[(4*i)+1]),40*Math.sin(Stars[(4*i)+1]),40*Math.sin(Stars[4*i])*Math.cos(Stars[(4*i)+1]),0),
				sY = getXYZ(40*Math.cos(Stars[4*i])*Math.cos(Stars[(4*i)+1]),40*Math.sin(Stars[(4*i)+1]),40*Math.sin(Stars[4*i])*Math.cos(Stars[(4*i)+1]),1),
				sZ = getXYZ(40*Math.cos(Stars[4*i])*Math.cos(Stars[(4*i)+1]),40*Math.sin(Stars[(4*i)+1]),40*Math.sin(Stars[4*i])*Math.cos(Stars[(4*i)+1]),2);
				p.fillOval(sZ>0?500+sX:-10,sZ>0?300+sY:-10,
						(int)Stars[(4 * i) + 2], (int)Stars[(4 * i) + 3]);
			}
		}

		public void makeAxis(Graphics p) {
			int[] axPts = new int[4];
			for (int i = 0; i < 3; i++) {
				p.setColor(i == 0 ? Color.green : (i == 1 ? Color.red : Color.yellow));
				for (int j = 0; j < 4; j++)
					axPts[j] = (int) ((j == 0 || j == 2 ? 500 : 300) + getXYZ((i == 0 ? (j > 1 ? -24 : 24) : 0),
							(i == 1 ? (j > 1 ? -24 : 24) : 0), (i == 2 ? (j > 1 ? -24 : 24) : 0), (j == 0 || j == 2)?0:1));
				p.drawLine(axPts[0], axPts[1], axPts[2], axPts[3]);
			}
			p.setFont(new Font("Helvetica", Font.BOLD, 16));
			p.setColor(Color.green);
			p.drawString("X", (int) (500 + getXYZ(25, 0, 0, 0)), (int) (300 + getXYZ(25, 0, 0, 1)));
			p.setColor(Color.red);
			p.drawString("Y", (int) (500 + getXYZ(0, 25, 0, 0)), (int) (300 + getXYZ(0, 25, 0, 1)));
			p.setColor(Color.yellow);
			p.drawString("Z", (int) (500 + getXYZ(0, 0, 25, 0)), (int) (300 + getXYZ(0, 0, 25, 1)));
			p.setColor(Color.white);
			int[][] circle = new int[120][180];
			for (int j = 0; j < 30; j++) {
				for (int i = 0; i < 180; i++) {
					circle[2 * j][i] = (int) (500
							+ getXYZ(20 * Math.sin(2*i / (180 / Math.PI)) * Math.cos(12 * j / (180 / Math.PI)),
									20 * Math.cos(2*i / (180 / Math.PI)) * Math.cos(12 * j / (180 / Math.PI)),
									20 * Math.sin(12 * j / (180 / Math.PI)), 0));
					circle[(2 * j) + 1][i] = (int) (300
							+ getXYZ(20 * Math.sin(2*i / (180 / Math.PI)) * Math.cos(12 * j / (180 / Math.PI)),
									20 * Math.cos(2*i / (180 / Math.PI)) * Math.cos(12 * j / (180 / Math.PI)),
									20 * Math.sin(12 * j / (180 / Math.PI)), 1));
					circle[(2 * j) + 60][i] = (int) (500
							+ getXYZ(20 * Math.sin(2*i / (180 / Math.PI)) * Math.sin(12 * j / (180 / Math.PI)),
									20 * Math.sin(2*i / (180 / Math.PI)) * Math.cos(12 * j / (180 / Math.PI)),
									20 * Math.cos(2*i / (180 / Math.PI)), 0));
					circle[(2 * j) + 61][i] = (int) (300
							+ getXYZ(20 * Math.sin(2*i / (180 / Math.PI)) * Math.sin(12 * j / (180 / Math.PI)),
									20 * Math.sin(2*i / (180 / Math.PI)) * Math.cos(12 * j / (180 / Math.PI)),
									20 * Math.cos(2*i / (180 / Math.PI)), 1));
				}
			}
			for (int i = 0; i < 60; i++)
				p.drawPolygon(circle[2 * i], circle[(2 * i) + 1], 180);
		}

	}

	public int getXYZ(double x, double y, double z, int XYZ) {
		x += .0001;
		y += .0001;
		z += .0001;
		x *= 10;
		y *= 10;
		z *= -10;
		
		double r = Math.sqrt((x*x)+(y*y)+(z*z)),
				rxy = Math.sqrt((x*x)+(y*y)),
				Hpt = Math.asin(y/rxy),
				Vpt = Math.asin(z/r);
		
		double X = 0,
				Y = 0,
				Z = 0;
		
		/*
		int front = (angleH < 361 && angleH > 179 ? 1 : -1);
		double c = Math.sqrt(Math.pow(y, 2) + Math.pow(x, 2) + Math.pow(z, 2)),
				b = Math.sqrt(Math.pow(X, 2) + Math.pow(Y, 2));
		double R = Math.sqrt((X*X)+(Y*Y));
		double ang = (X<=0?Math.PI-Math.asin(Y/R):Math.asin(Y/R));
		X = R*Math.cos((direc/(180/Math.PI)) +ang);
		Y = R*Math.sin((direc/(180/Math.PI)) +ang);
		int Z = (int) (Math.pow(.99, (Math.sqrt(Math.pow(c, 2) - Math.pow(b, 2)) / 10) * front * q));
		Z = 1;
		*/
		int q = x < 0 ? (z < 0 ? 3 : 2) : (z < 0 ? 4 : 1);
		r = Math.sqrt((x * x) + (y * y));
		double sA = q == 1 || q == 4 ? Math.asin(y / r) : Math.PI - Math.asin(y / r);
		Y = ((z * Math.sin(angleV + (Math.PI / 2))) + (r * Math.sin(angleV) * Math.cos(angleH + sA)));
		X = (r * Math.sin(angleH + sA));
		Z=(r*Math.cos(angleH + sA));
		return XYZ == 0 ? (int) (X) : (XYZ == 1 ? (int) (Y) : (int) (Z));
	}

	@Override
	public void mouseClicked(MouseEvent arg0) {}
	@Override
	public void mouseEntered(MouseEvent arg0) {}
	@Override
	public void mouseExited(MouseEvent arg0) {}

	@Override
	public void mousePressed(MouseEvent arg0) {
		iX = arg0.getPoint().x;
		iY = arg0.getPoint().y;
		dragging = true;
	}

	@Override
	public void mouseReleased(MouseEvent arg0) {
		curH = angleH;
		curV = angleV;
		dragging = false;
	}

	@Override
	public void keyPressed(KeyEvent arg0) {
		if(arg0.getKeyCode() == KeyEvent.VK_COMMA)
			spinL = true;
		if(arg0.getKeyCode() == KeyEvent.VK_PERIOD)
			spinR = true;
	}
	@Override
	public void keyReleased(KeyEvent arg0) {
		if(arg0.getKeyCode() == KeyEvent.VK_COMMA)
			spinL = false;
		if(arg0.getKeyCode() == KeyEvent.VK_PERIOD)
			spinR = false;
		if(arg0.getKeyCode() == KeyEvent.VK_S)
			rotateSim=(rotateSim?false:true);
		}
	@Override
	public void keyTyped(KeyEvent arg0) {}
	@Override
	public void actionPerformed(ActionEvent arg0) {}
	@Override
	public void mouseWheelMoved(MouseWheelEvent e) {}

	@Override
	public void mouseDragged(MouseEvent e) {
		curX = e.getPoint().x;
		curY = e.getPoint().y;
		if (dragging) {
			int Dx = curX - iX, Dy = curY - iY;
			angleH = ((double) Math.PI * (Dx) / 720) + curH;
			angleV = ((double) Math.PI * (Dy) / 720) + curV;
		}
	}

	@Override
	public void mouseMoved(MouseEvent e) {}

}
